var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"inv_mot_controller_v2","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"C:\\WORK\\MATLAB_models\\Mospoly\\Kamaz_electric_brakes_v2\\controller_r2023a\\inv_mot_controller_v2_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\r\n// File: ert_main.cpp\r\n//\r\n// Code generated for Simulink model 'inv_mot_controller_v2'.\r\n//\r\n// Model version                  : 1.4\r\n// Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n// C/C++ source code generated on : Thu May 23 22:34:38 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n#include <stdio.h>              // This example main program uses printf/fflush\r\n#include \"inv_mot_controller_v2.h\"     // Model header file\r\n\r\nstatic inv_mot_controller_v2 rtObj;    // Instance of model class\r\n\r\n//\r\n// Associating rt_OneStep with a real-time clock or interrupt service routine\r\n// is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n// always associated with the base rate of the model.  Subrates are managed\r\n// by the base rate from inside the generated code.  Enabling/disabling\r\n// interrupts and floating point context switches are target specific.  This\r\n// example code indicates where these should take place relative to executing\r\n// the generated code step function.  Overrun behavior should be tailored to\r\n// your application needs.  This example simply sets an error status in the\r\n// real-time model and returns from rt_OneStep.\r\n//\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag{ false };\r\n\r\n  // Disable interrupts here\r\n\r\n  // Check for overrun\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtObj.getRTM(), \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  // Save FPU context here (if necessary)\r\n  // Re-enable timer or interrupt here\r\n  // Set model inputs here\r\n\r\n  // Step the model\r\n  rtObj.step();\r\n\r\n  // Get model outputs here\r\n\r\n  // Indicate task complete\r\n  OverrunFlag = false;\r\n\r\n  // Disable interrupts here\r\n  // Restore FPU context here (if necessary)\r\n  // Enable interrupts here\r\n}\r\n\r\n//\r\n// The example main function illustrates what is required by your\r\n// application code to initialize, execute, and terminate the generated code.\r\n// Attaching rt_OneStep to a real-time clock is target specific. This example\r\n// illustrates how you do this relative to initializing the model.\r\n//\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  // Unused arguments\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  // Initialize model\r\n  rtObj.initialize();\r\n\r\n  // Attach rt_OneStep to a timer or interrupt service routine with\r\n  //  period 8.0E-5 seconds (base rate of the model) here.\r\n  //  The call syntax for rt_OneStep is\r\n  //\r\n  //   rt_OneStep();\r\n\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((nullptr));\r\n  while (rtmGetErrorStatus(rtObj.getRTM()) == (nullptr)) {\r\n    //  Perform application tasks here\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"inv_mot_controller_v2.cpp","type":"source","group":"model","path":"C:\\WORK\\MATLAB_models\\Mospoly\\Kamaz_electric_brakes_v2\\controller_r2023a\\inv_mot_controller_v2_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// File: inv_mot_controller_v2.cpp\r\n//\r\n// Code generated for Simulink model 'inv_mot_controller_v2'.\r\n//\r\n// Model version                  : 1.4\r\n// Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n// C/C++ source code generated on : Thu May 23 22:34:38 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n#include \"inv_mot_controller_v2.h\"\r\n#include \"rtwtypes.h\"\r\n#include <cmath>\r\n#include <cfloat>\r\n#include <stddef.h>\r\n#define NumBitsPerChar                 8U\r\n\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\nextern real_T rt_modd_snf(real_T u0, real_T u1);\r\nextern real_T rt_hypotd_snf(real_T u0, real_T u1);\r\n\r\n//===========*\r\n//  Constants *\r\n// ===========\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n//\r\n//  UNUSED_PARAMETER(x)\r\n//    Used to specify that a function parameter (argument) is required but not\r\n//    accessed by the function body.\r\n\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      // do nothing\r\n#else\r\n\r\n//\r\n//  This is the semi-ANSI standard way of indicating that an\r\n//  unused function parameter is required.\r\n\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n\r\nextern \"C\"\r\n{\r\n  real_T rtInf;\r\n  real_T rtMinusInf;\r\n  real_T rtNaN;\r\n  real32_T rtInfF;\r\n  real32_T rtMinusInfF;\r\n  real32_T rtNaNF;\r\n}\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize rtNaN needed by the generated code.\r\n  // NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static real_T rtGetNaN(void)\r\n  {\r\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\r\n\r\n    real_T nan{ 0.0 };\r\n\r\n    if (bitsPerReal == 32U) {\r\n      nan = rtGetNaNF();\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n      tmpVal.bitVal.words.wordL = 0x00000000U;\r\n      nan = tmpVal.fltVal;\r\n    }\r\n\r\n    return nan;\r\n  }\r\n\r\n  //\r\n  // Initialize rtNaNF needed by the generated code.\r\n  // NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static real32_T rtGetNaNF(void)\r\n  {\r\n    IEEESingle nanF{ { 0.0F } };\r\n\r\n    nanF.wordL.wordLuint = 0xFFC00000U;\r\n    return nanF.wordL.wordLreal;\r\n  }\r\n}\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static void rt_InitInfAndNaN(size_t realSize)\r\n  {\r\n    (void) (realSize);\r\n    rtNaN = rtGetNaN();\r\n    rtNaNF = rtGetNaNF();\r\n    rtInf = rtGetInf();\r\n    rtInfF = rtGetInfF();\r\n    rtMinusInf = rtGetMinusInf();\r\n    rtMinusInfF = rtGetMinusInfF();\r\n  }\r\n\r\n  // Test if value is infinite\r\n  static boolean_T rtIsInf(real_T value)\r\n  {\r\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n  }\r\n\r\n  // Test if single-precision value is infinite\r\n  static boolean_T rtIsInfF(real32_T value)\r\n  {\r\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n  }\r\n\r\n  // Test if value is not a number\r\n  static boolean_T rtIsNaN(real_T value)\r\n  {\r\n    boolean_T result{ (boolean_T) 0 };\r\n\r\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\r\n\r\n    if (bitsPerReal == 32U) {\r\n      result = rtIsNaNF((real32_T)value);\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.fltVal = value;\r\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                           0x7FF00000 &&\r\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                            (tmpVal.bitVal.words.wordL != 0) ));\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Test if single-precision value is not a number\r\n  static boolean_T rtIsNaNF(real32_T value)\r\n  {\r\n    IEEESingle tmp;\r\n    tmp.wordL.wordLreal = value;\r\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n  }\r\n}\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize rtInf needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static real_T rtGetInf(void)\r\n  {\r\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\r\n\r\n    real_T inf{ 0.0 };\r\n\r\n    if (bitsPerReal == 32U) {\r\n      inf = rtGetInfF();\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n      tmpVal.bitVal.words.wordL = 0x00000000U;\r\n      inf = tmpVal.fltVal;\r\n    }\r\n\r\n    return inf;\r\n  }\r\n\r\n  //\r\n  // Initialize rtInfF needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static real32_T rtGetInfF(void)\r\n  {\r\n    IEEESingle infF;\r\n    infF.wordL.wordLuint = 0x7F800000U;\r\n    return infF.wordL.wordLreal;\r\n  }\r\n\r\n  //\r\n  // Initialize rtMinusInf needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static real_T rtGetMinusInf(void)\r\n  {\r\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\r\n\r\n    real_T minf{ 0.0 };\r\n\r\n    if (bitsPerReal == 32U) {\r\n      minf = rtGetMinusInfF();\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n      tmpVal.bitVal.words.wordL = 0x00000000U;\r\n      minf = tmpVal.fltVal;\r\n    }\r\n\r\n    return minf;\r\n  }\r\n\r\n  //\r\n  // Initialize rtMinusInfF needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  static real32_T rtGetMinusInfF(void)\r\n  {\r\n    IEEESingle minfF;\r\n    minfF.wordL.wordLuint = 0xFF800000U;\r\n    return minfF.wordL.wordLreal;\r\n  }\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (std::isnan(u0) || std::isnan(u1)) {\r\n    y = (rtNaN);\r\n  } else if (std::isinf(u0) && std::isinf(u1)) {\r\n    int32_T tmp;\r\n    int32_T tmp_0;\r\n    if (u0 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = std::atan2(static_cast<real_T>(tmp), static_cast<real_T>(tmp_0));\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = std::atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nreal_T rt_modd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  y = u0;\r\n  if (u1 == 0.0) {\r\n    if (u0 == 0.0) {\r\n      y = u1;\r\n    }\r\n  } else if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (u0 == 0.0) {\r\n    y = 0.0 / u1;\r\n  } else if (std::isinf(u1)) {\r\n    if ((u1 < 0.0) != (u0 < 0.0)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    boolean_T yEq;\r\n    y = std::fmod(u0, u1);\r\n    yEq = (y == 0.0);\r\n    if ((!yEq) && (u1 > std::floor(u1))) {\r\n      real_T q;\r\n      q = std::abs(u0 / u1);\r\n      yEq = !(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0;\r\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nreal_T rt_hypotd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T a;\r\n  real_T b;\r\n  real_T y;\r\n  a = std::abs(u0);\r\n  b = std::abs(u1);\r\n  if (a < b) {\r\n    a /= b;\r\n    y = std::sqrt(a * a + 1.0) * b;\r\n  } else if (a > b) {\r\n    b /= a;\r\n    y = std::sqrt(b * b + 1.0) * a;\r\n  } else if (std::isnan(b)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    y = a * 1.4142135623730951;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n// Model step function\r\nvoid inv_mot_controller_v2::step()\r\n{\r\n  real_T rtb_Add1;\r\n  real_T rtb_Cos;\r\n  real_T rtb_DeadZone;\r\n  real_T rtb_DeadZone_n;\r\n  real_T rtb_Diff;\r\n  real_T rtb_IntegralGain;\r\n  real_T rtb_IntegralGain_b;\r\n  real_T rtb_IntegralGain_e;\r\n  real_T rtb_Integrator_m;\r\n  real_T rtb_Saturation;\r\n  real_T rtb_Sin;\r\n  real_T rtb_Switch_o_idx_0;\r\n  real_T rtb_Switch_o_idx_0_tmp;\r\n  int32_T n;\r\n  int8_T tmp;\r\n  int8_T tmp_0;\r\n  boolean_T rtb_Compare_d;\r\n  boolean_T rtb_NOT;\r\n\r\n  // Gain: '<Root>/Gain' incorporates:\r\n  //   Inport: '<Root>/RotorAngle'\r\n\r\n  rtb_IntegralGain = 4.0 * rtU.RotorAngle;\r\n\r\n  // Trigonometry: '<Root>/Sin'\r\n  rtb_Sin = std::sin(rtb_IntegralGain);\r\n\r\n  // Trigonometry: '<Root>/Cos'\r\n  rtb_Cos = std::cos(rtb_IntegralGain);\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Clarke Transform'\r\n  // Gain: '<S2>/one_by_sqrt3' incorporates:\r\n  //   Inport: '<Root>/Ia'\r\n  //   Inport: '<Root>/Ib'\r\n  //   Sum: '<S2>/a_plus_2b'\r\n\r\n  rtb_IntegralGain = ((rtU.Ia + rtU.Ib) + rtU.Ib) * 0.57735026918962584;\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Park Transform'\r\n  // Sum: '<S13>/sum_Ds' incorporates:\r\n  //   AlgorithmDescriptorDelegate generated from: '<S2>/a16'\r\n  //   Inport: '<Root>/Ia'\r\n  //   Product: '<S13>/acos'\r\n  //   Product: '<S13>/bsin'\r\n\r\n  rtb_Switch_o_idx_0_tmp = rtU.Ia * rtb_Cos + rtb_IntegralGain * rtb_Sin;\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Clarke Transform'\r\n\r\n  // Sum: '<S163>/Sum' incorporates:\r\n  //   Constant: '<Root>/Constant3'\r\n  //   DiscreteIntegrator: '<S154>/Integrator'\r\n  //   Gain: '<S159>/Proportional Gain'\r\n  //   Sum: '<Root>/Sum'\r\n  //   Sum: '<S13>/sum_Ds'\r\n\r\n  rtb_DeadZone = (0.0 - rtb_Switch_o_idx_0_tmp) * 0.15 + rtDW.Integrator_DSTATE;\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Park Transform'\r\n\r\n  // Saturate: '<S161>/Saturation'\r\n  if (rtb_DeadZone > 15.0) {\r\n    rtb_Saturation = 15.0;\r\n  } else if (rtb_DeadZone < -15.0) {\r\n    rtb_Saturation = -15.0;\r\n  } else {\r\n    rtb_Saturation = rtb_DeadZone;\r\n  }\r\n\r\n  // End of Saturate: '<S161>/Saturation'\r\n\r\n  // Product: '<Root>/Product' incorporates:\r\n  //   Gain: '<Root>/Gain2'\r\n  //   Inport: '<Root>/CurrentLimit'\r\n  //   Inport: '<Root>/pedal'\r\n\r\n  rtb_Diff = 0.01 * rtU.pedal * rtU.CurrentLimit;\r\n\r\n  // RelationalOperator: '<S6>/Compare' incorporates:\r\n  //   Constant: '<S6>/Constant'\r\n\r\n  rtb_Compare_d = (rtb_Diff <= 0.0);\r\n\r\n  // Logic: '<Root>/NOT'\r\n  rtb_NOT = !rtb_Compare_d;\r\n\r\n  // DiscreteIntegrator: '<Root>/Discrete-Time Integrator' incorporates:\r\n  //   DataTypeConversion: '<Root>/Data Type Conversion'\r\n\r\n  if (rtb_NOT && (rtDW.DiscreteTimeIntegrator_PrevRese <= 0)) {\r\n    rtDW.DiscreteTimeIntegrator_DSTATE = 0.0;\r\n  }\r\n\r\n  // Switch: '<Root>/Switch1' incorporates:\r\n  //   Constant: '<S3>/Constant'\r\n  //   Constant: '<S5>/Constant'\r\n  //   DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\r\n  //   Inport: '<Root>/RotationAngle'\r\n  //   Inport: '<Root>/Speed'\r\n  //   Logic: '<Root>/AND'\r\n  //   RelationalOperator: '<S3>/Compare'\r\n  //   RelationalOperator: '<S5>/Compare'\r\n\r\n  if ((!(rtU.Speed <= 0.1)) || (!(rtDW.DiscreteTimeIntegrator_DSTATE >= 0.01)))\r\n  {\r\n    rtb_Diff = rtU.RotationAngle;\r\n  }\r\n\r\n  // End of Switch: '<Root>/Switch1'\r\n\r\n  // Gain: '<S207>/Proportional Gain' incorporates:\r\n  //   Inport: '<Root>/ReturnAngle'\r\n  //   Inport: '<Root>/RotorAngle'\r\n  //   Quantizer: '<Root>/Quantizer'\r\n  //   Sum: '<Root>/Sum4'\r\n\r\n  rtb_Integrator_m = std::round((rtU.ReturnAngle - rtU.RotorAngle) / 0.1) * 0.1 *\r\n    50.0;\r\n\r\n  // Saturate: '<S209>/Saturation'\r\n  if (rtb_Integrator_m > 35.0) {\r\n    rtb_Integrator_m = 35.0;\r\n  } else if (rtb_Integrator_m < -315.0) {\r\n    rtb_Integrator_m = -315.0;\r\n  }\r\n\r\n  // End of Saturate: '<S209>/Saturation'\r\n\r\n  // Sum: '<S17>/Add1' incorporates:\r\n  //   Constant: '<S17>/Filter_Constant'\r\n  //   Constant: '<S17>/One'\r\n  //   Inport: '<Root>/Speed'\r\n  //   Product: '<S17>/Product'\r\n  //   Product: '<S17>/Product1'\r\n  //   UnitDelay: '<S17>/Unit Delay'\r\n\r\n  rtb_Add1 = rtU.Speed * 0.7 + 0.30000000000000004 * rtDW.UnitDelay_DSTATE;\r\n\r\n  // Switch: '<Root>/Switch' incorporates:\r\n  //   Inport: '<Root>/TargerBreakSpeed'\r\n\r\n  if (rtb_Compare_d) {\r\n    rtb_Switch_o_idx_0 = rtb_Integrator_m;\r\n  } else {\r\n    rtb_Switch_o_idx_0 = rtU.TargerBreakSpeed;\r\n  }\r\n\r\n  // Sum: '<Root>/Sum3' incorporates:\r\n  //   Switch: '<Root>/Switch'\r\n\r\n  rtb_IntegralGain_e = rtb_Switch_o_idx_0 - rtb_Add1;\r\n\r\n  // RelationalOperator: '<S4>/Compare' incorporates:\r\n  //   Constant: '<S4>/Constant'\r\n\r\n  rtb_Compare_d = (rtb_Integrator_m <= -0.1);\r\n\r\n  // DiscreteIntegrator: '<S103>/Integrator'\r\n  if ((!rtb_Compare_d) && (rtDW.Integrator_PrevResetState == 1)) {\r\n    rtDW.Integrator_DSTATE_m = 0.0;\r\n  }\r\n\r\n  // Sum: '<S113>/Sum' incorporates:\r\n  //   DiscreteIntegrator: '<S103>/Integrator'\r\n  //   Gain: '<S108>/Proportional Gain'\r\n\r\n  rtb_Integrator_m = 0.6 * rtb_IntegralGain_e + rtDW.Integrator_DSTATE_m;\r\n\r\n  // Switch: '<S111>/Switch2' incorporates:\r\n  //   Inport: '<Root>/ReturnCurrentLimit'\r\n  //   RelationalOperator: '<S111>/LowerRelop1'\r\n  //   RelationalOperator: '<S111>/UpperRelop'\r\n  //   Switch: '<S111>/Switch'\r\n\r\n  if (rtb_Integrator_m > rtb_Diff) {\r\n    rtb_Switch_o_idx_0 = rtb_Diff;\r\n  } else if (rtb_Integrator_m < rtU.ReturnCurrentLimit) {\r\n    // Switch: '<S111>/Switch' incorporates:\r\n    //   Inport: '<Root>/ReturnCurrentLimit'\r\n\r\n    rtb_Switch_o_idx_0 = rtU.ReturnCurrentLimit;\r\n  } else {\r\n    rtb_Switch_o_idx_0 = rtb_Integrator_m;\r\n  }\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Park Transform'\r\n  // Outputs for Atomic SubSystem: '<Root>/Clarke Transform'\r\n  // Sum: '<Root>/Sum1' incorporates:\r\n  //   AlgorithmDescriptorDelegate generated from: '<S2>/a16'\r\n  //   Inport: '<Root>/Ia'\r\n  //   Product: '<S13>/asin'\r\n  //   Product: '<S13>/bcos'\r\n  //   Sum: '<S13>/sum_Qs'\r\n  //   Switch: '<S111>/Switch2'\r\n\r\n  rtb_IntegralGain_b = rtb_Switch_o_idx_0 - (rtb_IntegralGain * rtb_Cos - rtU.Ia\r\n    * rtb_Sin);\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Clarke Transform'\r\n  // End of Outputs for SubSystem: '<Root>/Park Transform'\r\n\r\n  // Sum: '<S61>/Sum' incorporates:\r\n  //   DiscreteIntegrator: '<S52>/Integrator'\r\n  //   Gain: '<S57>/Proportional Gain'\r\n\r\n  rtb_DeadZone_n = 0.15 * rtb_IntegralGain_b + rtDW.Integrator_DSTATE_j;\r\n\r\n  // Saturate: '<S59>/Saturation'\r\n  if (rtb_DeadZone_n > 15.0) {\r\n    rtb_Switch_o_idx_0 = 15.0;\r\n  } else if (rtb_DeadZone_n < -15.0) {\r\n    rtb_Switch_o_idx_0 = -15.0;\r\n  } else {\r\n    rtb_Switch_o_idx_0 = rtb_DeadZone_n;\r\n  }\r\n\r\n  // Sum: '<Root>/Sum2' incorporates:\r\n  //   Gain: '<Root>/Gain1'\r\n  //   Saturate: '<S59>/Saturation'\r\n\r\n  rtb_IntegralGain = 0.0376432375511636 * rtb_Add1 + rtb_Switch_o_idx_0;\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Inverse Park Transform'\r\n  // Switch: '<S18>/Switch' incorporates:\r\n  //   Product: '<S8>/dcos'\r\n  //   Product: '<S8>/dsin'\r\n  //   Product: '<S8>/qcos'\r\n  //   Product: '<S8>/qsin'\r\n  //   Sum: '<S8>/sum_alpha'\r\n  //   Sum: '<S8>/sum_beta'\r\n\r\n  rtb_Switch_o_idx_0 = rtb_Saturation * rtb_Cos - rtb_IntegralGain * rtb_Sin;\r\n  rtb_Sin = rtb_IntegralGain * rtb_Cos + rtb_Saturation * rtb_Sin;\r\n\r\n  // Math: '<Root>/Mod' incorporates:\r\n  //   AlgorithmDescriptorDelegate generated from: '<S8>/a16'\r\n  //   Constant: '<Root>/Constant'\r\n  //   Fcn: '<S1>/x->theta'\r\n\r\n  rtb_Cos = rt_modd_snf(rt_atan2d_snf(rtb_Sin, rtb_Switch_o_idx_0),\r\n                        6.2831853071795862);\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Inverse Park Transform'\r\n\r\n  // MATLAB Function: '<Root>/SVPWM' incorporates:\r\n  //   AlgorithmDescriptorDelegate generated from: '<S8>/a16'\r\n  //   Fcn: '<S1>/x->r'\r\n  //   Inport: '<Root>/Ia'\r\n  //   Inport: '<Root>/Ib'\r\n  //   Inport: '<Root>/VDC'\r\n\r\n  if ((rtb_Cos >= 0.0) && (rtb_Cos < 1.0471975511965976)) {\r\n    n = 1;\r\n  } else if ((rtb_Cos >= 1.0471975511965976) && (rtb_Cos < 2.0943951023931953))\r\n  {\r\n    n = 2;\r\n  } else if ((rtb_Cos >= 2.0943951023931953) && (rtb_Cos < 3.1415926535897931))\r\n  {\r\n    n = 3;\r\n  } else if ((rtb_Cos >= 3.1415926535897931) && (rtb_Cos < 4.1887902047863905))\r\n  {\r\n    n = 4;\r\n  } else if ((rtb_Cos >= 4.1887902047863905) && (rtb_Cos < 5.2359877559829888))\r\n  {\r\n    n = 5;\r\n  } else {\r\n    n = 6;\r\n  }\r\n\r\n  rtb_Saturation = rtb_Cos - (static_cast<real_T>(n) - 1.0) * 3.1415926535897931\r\n    / 3.0;\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Inverse Park Transform'\r\n  rtb_Sin = rt_hypotd_snf(rtb_Switch_o_idx_0, rtb_Sin) / rtU.VDC;\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Inverse Park Transform'\r\n  rtb_Cos = std::sin(1.0471975511965976 - rtb_Saturation) * rtb_Sin /\r\n    0.8660254037844386;\r\n  rtb_Saturation = rtb_Sin * std::sin(rtb_Saturation) / 0.8660254037844386;\r\n  rtb_Switch_o_idx_0 = (1.0 - rtb_Cos) - rtb_Saturation;\r\n  switch (n) {\r\n   case 1:\r\n    rtb_IntegralGain = (rtb_Cos + rtb_Saturation) + rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Sin = rtb_Switch_o_idx_0 / 2.0 + rtb_Saturation;\r\n    rtb_Saturation = rtb_Switch_o_idx_0 / 2.0;\r\n    break;\r\n\r\n   case 2:\r\n    rtb_IntegralGain = rtb_Switch_o_idx_0 / 2.0 + rtb_Cos;\r\n    rtb_Sin = (rtb_Cos + rtb_Saturation) + rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Saturation = rtb_Switch_o_idx_0 / 2.0;\r\n    break;\r\n\r\n   case 3:\r\n    rtb_IntegralGain = rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Sin = (rtb_Cos + rtb_Saturation) + rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Saturation += rtb_Switch_o_idx_0 / 2.0;\r\n    break;\r\n\r\n   case 4:\r\n    rtb_IntegralGain = rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Sin = rtb_Switch_o_idx_0 / 2.0 + rtb_Cos;\r\n    rtb_Saturation = (rtb_Cos + rtb_Saturation) + rtb_Switch_o_idx_0 / 2.0;\r\n    break;\r\n\r\n   case 5:\r\n    rtb_IntegralGain = rtb_Switch_o_idx_0 / 2.0 + rtb_Saturation;\r\n    rtb_Sin = rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Saturation = (rtb_Cos + rtb_Saturation) + rtb_Switch_o_idx_0 / 2.0;\r\n    break;\r\n\r\n   default:\r\n    rtb_IntegralGain = (rtb_Cos + rtb_Saturation) + rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Sin = rtb_Switch_o_idx_0 / 2.0;\r\n    rtb_Saturation = rtb_Switch_o_idx_0 / 2.0 + rtb_Cos;\r\n    break;\r\n  }\r\n\r\n  if (rtb_IntegralGain > 0.95) {\r\n    rtb_IntegralGain = 0.95;\r\n  } else if (rtb_IntegralGain < 0.05) {\r\n    rtb_IntegralGain = 0.05;\r\n  }\r\n\r\n  if (rtb_Sin > 0.95) {\r\n    rtb_Sin = 0.95;\r\n  } else if (rtb_Sin < 0.05) {\r\n    rtb_Sin = 0.05;\r\n  }\r\n\r\n  if (rtb_Saturation > 0.95) {\r\n    rtb_Saturation = 0.95;\r\n  } else if (rtb_Saturation < 0.05) {\r\n    rtb_Saturation = 0.05;\r\n  }\r\n\r\n  if (rtU.Ia > 0.0) {\r\n    // Outport: '<Root>/Ts1'\r\n    rtY.Ts1 = (rtb_IntegralGain - 0.0046875) + 0.0046875;\r\n\r\n    // Outport: '<Root>/Ts2'\r\n    rtY.Ts2 = (rtb_IntegralGain + 0.0046875) + 0.0046875;\r\n  } else {\r\n    // Outport: '<Root>/Ts1'\r\n    rtY.Ts1 = (rtb_IntegralGain - 0.0046875) - 0.0046875;\r\n\r\n    // Outport: '<Root>/Ts2'\r\n    rtY.Ts2 = (rtb_IntegralGain + 0.0046875) - 0.0046875;\r\n  }\r\n\r\n  if (rtU.Ib > 0.0) {\r\n    // Outport: '<Root>/Ts3'\r\n    rtY.Ts3 = (rtb_Sin - 0.0046875) + 0.0046875;\r\n\r\n    // Outport: '<Root>/Ts4'\r\n    rtY.Ts4 = (rtb_Sin + 0.0046875) + 0.0046875;\r\n  } else {\r\n    // Outport: '<Root>/Ts3'\r\n    rtY.Ts3 = (rtb_Sin - 0.0046875) - 0.0046875;\r\n\r\n    // Outport: '<Root>/Ts4'\r\n    rtY.Ts4 = (rtb_Sin + 0.0046875) - 0.0046875;\r\n  }\r\n\r\n  if (-rtU.Ia - rtU.Ib > 0.0) {\r\n    // Outport: '<Root>/Ts5'\r\n    rtY.Ts5 = (rtb_Saturation - 0.0046875) + 0.0046875;\r\n\r\n    // Outport: '<Root>/Ts6'\r\n    rtY.Ts6 = (rtb_Saturation + 0.0046875) + 0.0046875;\r\n  } else {\r\n    // Outport: '<Root>/Ts5'\r\n    rtY.Ts5 = (rtb_Saturation - 0.0046875) - 0.0046875;\r\n\r\n    // Outport: '<Root>/Ts6'\r\n    rtY.Ts6 = (rtb_Saturation + 0.0046875) - 0.0046875;\r\n  }\r\n\r\n  // End of MATLAB Function: '<Root>/SVPWM'\r\n\r\n  // DeadZone: '<S45>/DeadZone'\r\n  if (rtb_DeadZone_n > 15.0) {\r\n    rtb_DeadZone_n -= 15.0;\r\n  } else if (rtb_DeadZone_n >= -15.0) {\r\n    rtb_DeadZone_n = 0.0;\r\n  } else {\r\n    rtb_DeadZone_n -= -15.0;\r\n  }\r\n\r\n  // End of DeadZone: '<S45>/DeadZone'\r\n\r\n  // Gain: '<S49>/Integral Gain'\r\n  rtb_IntegralGain_b *= 89.85;\r\n\r\n  // Switch: '<S96>/Switch' incorporates:\r\n  //   RelationalOperator: '<S96>/u_GTE_up'\r\n\r\n  if (!(rtb_Integrator_m >= rtb_Diff)) {\r\n    // Switch: '<S96>/Switch1' incorporates:\r\n    //   Inport: '<Root>/ReturnCurrentLimit'\r\n    //   RelationalOperator: '<S96>/u_GT_lo'\r\n\r\n    if (rtb_Integrator_m > rtU.ReturnCurrentLimit) {\r\n      rtb_Diff = rtb_Integrator_m;\r\n    } else {\r\n      rtb_Diff = rtU.ReturnCurrentLimit;\r\n    }\r\n\r\n    // End of Switch: '<S96>/Switch1'\r\n  }\r\n\r\n  // End of Switch: '<S96>/Switch'\r\n\r\n  // Sum: '<S96>/Diff'\r\n  rtb_Diff = rtb_Integrator_m - rtb_Diff;\r\n\r\n  // DeadZone: '<S147>/DeadZone'\r\n  if (rtb_DeadZone > 15.0) {\r\n    rtb_DeadZone -= 15.0;\r\n  } else if (rtb_DeadZone >= -15.0) {\r\n    rtb_DeadZone = 0.0;\r\n  } else {\r\n    rtb_DeadZone -= -15.0;\r\n  }\r\n\r\n  // End of DeadZone: '<S147>/DeadZone'\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Park Transform'\r\n  // Gain: '<S151>/Integral Gain' incorporates:\r\n  //   Constant: '<Root>/Constant3'\r\n  //   Sum: '<Root>/Sum'\r\n\r\n  rtb_IntegralGain = (0.0 - rtb_Switch_o_idx_0_tmp) * 89.85;\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Park Transform'\r\n\r\n  // Switch: '<S145>/Switch1' incorporates:\r\n  //   Constant: '<S145>/Clamping_zero'\r\n  //   Constant: '<S145>/Constant'\r\n  //   Constant: '<S145>/Constant2'\r\n  //   RelationalOperator: '<S145>/fix for DT propagation issue'\r\n\r\n  if (rtb_DeadZone > 0.0) {\r\n    tmp = 1;\r\n  } else {\r\n    tmp = -1;\r\n  }\r\n\r\n  // Switch: '<S145>/Switch2' incorporates:\r\n  //   Constant: '<S145>/Clamping_zero'\r\n  //   Constant: '<S145>/Constant3'\r\n  //   Constant: '<S145>/Constant4'\r\n  //   RelationalOperator: '<S145>/fix for DT propagation issue1'\r\n\r\n  if (rtb_IntegralGain > 0.0) {\r\n    tmp_0 = 1;\r\n  } else {\r\n    tmp_0 = -1;\r\n  }\r\n\r\n  // Switch: '<S145>/Switch' incorporates:\r\n  //   Constant: '<S145>/Clamping_zero'\r\n  //   Constant: '<S145>/Constant1'\r\n  //   Logic: '<S145>/AND3'\r\n  //   RelationalOperator: '<S145>/Equal1'\r\n  //   RelationalOperator: '<S145>/Relational Operator'\r\n  //   Switch: '<S145>/Switch1'\r\n  //   Switch: '<S145>/Switch2'\r\n\r\n  if ((rtb_DeadZone != 0.0) && (tmp == tmp_0)) {\r\n    rtb_IntegralGain = 0.0;\r\n  }\r\n\r\n  // Update for DiscreteIntegrator: '<S154>/Integrator' incorporates:\r\n  //   Switch: '<S145>/Switch'\r\n\r\n  rtDW.Integrator_DSTATE += 8.0E-5 * rtb_IntegralGain;\r\n\r\n  // Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator' incorporates:\r\n  //   DataTypeConversion: '<Root>/Data Type Conversion'\r\n\r\n  rtDW.DiscreteTimeIntegrator_DSTATE += 8.0E-5 * static_cast<real_T>(rtb_NOT);\r\n  if (rtb_NOT) {\r\n    rtDW.DiscreteTimeIntegrator_PrevRese = 1;\r\n  } else {\r\n    rtDW.DiscreteTimeIntegrator_PrevRese = 0;\r\n  }\r\n\r\n  // End of Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\r\n\r\n  // Update for UnitDelay: '<S17>/Unit Delay'\r\n  rtDW.UnitDelay_DSTATE = rtb_Add1;\r\n\r\n  // Switch: '<S93>/Switch1' incorporates:\r\n  //   Constant: '<S93>/Clamping_zero'\r\n  //   Constant: '<S93>/Constant'\r\n  //   Constant: '<S93>/Constant2'\r\n  //   RelationalOperator: '<S93>/fix for DT propagation issue'\r\n\r\n  if (rtb_Diff > 0.0) {\r\n    tmp = 1;\r\n  } else {\r\n    tmp = -1;\r\n  }\r\n\r\n  // Switch: '<S93>/Switch' incorporates:\r\n  //   Constant: '<S93>/Clamping_zero'\r\n  //   Constant: '<S93>/Constant1'\r\n  //   Gain: '<S100>/Integral Gain'\r\n  //   Logic: '<S93>/AND3'\r\n  //   RelationalOperator: '<S93>/Equal1'\r\n  //   RelationalOperator: '<S93>/Relational Operator'\r\n  //   Switch: '<S93>/Switch1'\r\n  //   Switch: '<S93>/Switch2'\r\n\r\n  if ((rtb_Diff != 0.0) && (tmp == -1)) {\r\n    rtb_Switch_o_idx_0 = 0.0;\r\n  } else {\r\n    rtb_Switch_o_idx_0 = 0.0 * rtb_IntegralGain_e;\r\n  }\r\n\r\n  // Update for DiscreteIntegrator: '<S103>/Integrator' incorporates:\r\n  //   Switch: '<S93>/Switch'\r\n\r\n  rtDW.Integrator_DSTATE_m += 8.0E-5 * rtb_Switch_o_idx_0;\r\n  rtDW.Integrator_PrevResetState = static_cast<int8_T>(rtb_Compare_d);\r\n\r\n  // Switch: '<S43>/Switch1' incorporates:\r\n  //   Constant: '<S43>/Clamping_zero'\r\n  //   Constant: '<S43>/Constant'\r\n  //   Constant: '<S43>/Constant2'\r\n  //   RelationalOperator: '<S43>/fix for DT propagation issue'\r\n\r\n  if (rtb_DeadZone_n > 0.0) {\r\n    tmp = 1;\r\n  } else {\r\n    tmp = -1;\r\n  }\r\n\r\n  // Switch: '<S43>/Switch2' incorporates:\r\n  //   Constant: '<S43>/Clamping_zero'\r\n  //   Constant: '<S43>/Constant3'\r\n  //   Constant: '<S43>/Constant4'\r\n  //   RelationalOperator: '<S43>/fix for DT propagation issue1'\r\n\r\n  if (rtb_IntegralGain_b > 0.0) {\r\n    tmp_0 = 1;\r\n  } else {\r\n    tmp_0 = -1;\r\n  }\r\n\r\n  // Switch: '<S43>/Switch' incorporates:\r\n  //   Constant: '<S43>/Clamping_zero'\r\n  //   Constant: '<S43>/Constant1'\r\n  //   Logic: '<S43>/AND3'\r\n  //   RelationalOperator: '<S43>/Equal1'\r\n  //   RelationalOperator: '<S43>/Relational Operator'\r\n  //   Switch: '<S43>/Switch1'\r\n  //   Switch: '<S43>/Switch2'\r\n\r\n  if ((rtb_DeadZone_n != 0.0) && (tmp == tmp_0)) {\r\n    rtb_IntegralGain_b = 0.0;\r\n  }\r\n\r\n  // Update for DiscreteIntegrator: '<S52>/Integrator' incorporates:\r\n  //   Switch: '<S43>/Switch'\r\n\r\n  rtDW.Integrator_DSTATE_j += 8.0E-5 * rtb_IntegralGain_b;\r\n}\r\n\r\n// Model initialize function\r\nvoid inv_mot_controller_v2::initialize()\r\n{\r\n  // Registration code\r\n\r\n  // initialize non-finites\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<Root>/Discrete-Time Integrator' \r\n  rtDW.DiscreteTimeIntegrator_PrevRese = 2;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S103>/Integrator'\r\n  rtDW.Integrator_PrevResetState = 2;\r\n}\r\n\r\n// Constructor\r\ninv_mot_controller_v2::inv_mot_controller_v2() :\r\n  rtU(),\r\n  rtY(),\r\n  rtDW(),\r\n  rtM()\r\n{\r\n  // Currently there is no constructor body generated.\r\n}\r\n\r\n// Destructor\r\n// Currently there is no destructor body generated.\r\ninv_mot_controller_v2::~inv_mot_controller_v2() = default;\r\n\r\n// Real-Time Model get method\r\ninv_mot_controller_v2::RT_MODEL * inv_mot_controller_v2::getRTM()\r\n{\r\n  return (&rtM);\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"inv_mot_controller_v2.h","type":"header","group":"model","path":"C:\\WORK\\MATLAB_models\\Mospoly\\Kamaz_electric_brakes_v2\\controller_r2023a\\inv_mot_controller_v2_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// File: inv_mot_controller_v2.h\r\n//\r\n// Code generated for Simulink model 'inv_mot_controller_v2'.\r\n//\r\n// Model version                  : 1.4\r\n// Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n// C/C++ source code generated on : Thu May 23 22:34:38 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_inv_mot_controller_v2_h_\r\n#define RTW_HEADER_inv_mot_controller_v2_h_\r\n#include \"rtwtypes.h\"\r\n#include <stddef.h>\r\n\r\n// Macros for accessing real-time model data structure\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\nextern \"C\"\r\n{\r\n  static real_T rtGetNaN(void);\r\n  static real32_T rtGetNaNF(void);\r\n}                                      // extern \"C\"\r\n\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern \"C\"\r\n{\r\n  extern real_T rtInf;\r\n  extern real_T rtMinusInf;\r\n  extern real_T rtNaN;\r\n  extern real32_T rtInfF;\r\n  extern real32_T rtMinusInfF;\r\n  extern real32_T rtNaNF;\r\n  static void rt_InitInfAndNaN(size_t realSize);\r\n  static boolean_T rtIsInf(real_T value);\r\n  static boolean_T rtIsInfF(real32_T value);\r\n  static boolean_T rtIsNaN(real_T value);\r\n  static boolean_T rtIsNaNF(real32_T value);\r\n  struct BigEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordH;\r\n      uint32_T wordL;\r\n    } words;\r\n  };\r\n\r\n  struct LittleEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  };\r\n\r\n  struct IEEESingle {\r\n    union {\r\n      real32_T wordLreal;\r\n      uint32_T wordLuint;\r\n    } wordL;\r\n  };\r\n}                                      // extern \"C\"\r\n\r\nextern \"C\"\r\n{\r\n  static real_T rtGetInf(void);\r\n  static real32_T rtGetInfF(void);\r\n  static real_T rtGetMinusInf(void);\r\n  static real32_T rtGetMinusInfF(void);\r\n}                                      // extern \"C\"\r\n\r\n// Class declaration for model inv_mot_controller_v2\r\nclass inv_mot_controller_v2 final\r\n{\r\n  // public data and function members\r\n public:\r\n  // Block signals and states (default storage) for system '<Root>'\r\n  struct DW {\r\n    real_T Integrator_DSTATE;          // '<S154>/Integrator'\r\n    real_T DiscreteTimeIntegrator_DSTATE;// '<Root>/Discrete-Time Integrator'\r\n    real_T UnitDelay_DSTATE;           // '<S17>/Unit Delay'\r\n    real_T Integrator_DSTATE_m;        // '<S103>/Integrator'\r\n    real_T Integrator_DSTATE_j;        // '<S52>/Integrator'\r\n    int8_T DiscreteTimeIntegrator_PrevRese;// '<Root>/Discrete-Time Integrator'\r\n    int8_T Integrator_PrevResetState;  // '<S103>/Integrator'\r\n  };\r\n\r\n  // External inputs (root inport signals with default storage)\r\n  struct ExtU {\r\n    real_T Ia;                         // '<Root>/Ia'\r\n    real_T Ib;                         // '<Root>/Ib'\r\n    real_T TargerBreakSpeed;           // '<Root>/TargerBreakSpeed'\r\n    real_T pedal;                      // '<Root>/pedal'\r\n    real_T CurrentLimit;               // '<Root>/CurrentLimit'\r\n    real_T ReturnAngle;                // '<Root>/ReturnAngle'\r\n    real_T RotorAngle;                 // '<Root>/RotorAngle'\r\n    real_T RotationAngle;              // '<Root>/RotationAngle'\r\n    real_T Speed;                      // '<Root>/Speed'\r\n    real_T ReturnCurrentLimit;         // '<Root>/ReturnCurrentLimit'\r\n    real_T VDC;                        // '<Root>/VDC'\r\n  };\r\n\r\n  // External outputs (root outports fed by signals with default storage)\r\n  struct ExtY {\r\n    real_T Ts1;                        // '<Root>/Ts1'\r\n    real_T Ts2;                        // '<Root>/Ts2'\r\n    real_T Ts3;                        // '<Root>/Ts3'\r\n    real_T Ts4;                        // '<Root>/Ts4'\r\n    real_T Ts5;                        // '<Root>/Ts5'\r\n    real_T Ts6;                        // '<Root>/Ts6'\r\n  };\r\n\r\n  // Real-time Model Data Structure\r\n  struct RT_MODEL {\r\n    const char_T * volatile errorStatus;\r\n  };\r\n\r\n  // Copy Constructor\r\n  inv_mot_controller_v2(inv_mot_controller_v2 const&) = delete;\r\n\r\n  // Assignment Operator\r\n  inv_mot_controller_v2& operator= (inv_mot_controller_v2 const&) & = delete;\r\n\r\n  // Move Constructor\r\n  inv_mot_controller_v2(inv_mot_controller_v2 &&) = delete;\r\n\r\n  // Move Assignment Operator\r\n  inv_mot_controller_v2& operator= (inv_mot_controller_v2 &&) = delete;\r\n\r\n  // Real-Time Model get method\r\n  inv_mot_controller_v2::RT_MODEL * getRTM();\r\n\r\n  // External inputs\r\n  ExtU rtU;\r\n\r\n  // External outputs\r\n  ExtY rtY;\r\n\r\n  // model initialize function\r\n  void initialize();\r\n\r\n  // model step function\r\n  void step();\r\n\r\n  // Constructor\r\n  inv_mot_controller_v2();\r\n\r\n  // Destructor\r\n  ~inv_mot_controller_v2();\r\n\r\n  // private data and function members\r\n private:\r\n  // Block states\r\n  DW rtDW;\r\n\r\n  // Real-Time Model\r\n  RT_MODEL rtM;\r\n};\r\n\r\n//-\r\n//  These blocks were eliminated from the model due to optimizations:\r\n//\r\n//  Block '<S2>/Data Type Duplicate' : Unused code path elimination\r\n//  Block '<S17>/Data Type Duplicate' : Unused code path elimination\r\n//  Block '<S8>/Data Type Duplicate' : Unused code path elimination\r\n//  Block '<S8>/Data Type Duplicate1' : Unused code path elimination\r\n//  Block '<S111>/Data Type Duplicate' : Unused code path elimination\r\n//  Block '<S111>/Data Type Propagation' : Unused code path elimination\r\n//  Block '<S13>/Data Type Duplicate' : Unused code path elimination\r\n//  Block '<S13>/Data Type Duplicate1' : Unused code path elimination\r\n//  Block '<Root>/Scope3' : Unused code path elimination\r\n//  Block '<Root>/Scope5' : Unused code path elimination\r\n//  Block '<Root>/Scope6' : Unused code path elimination\r\n//  Block '<Root>/Scope7' : Unused code path elimination\r\n//  Block '<S18>/Offset' : Unused code path elimination\r\n//  Block '<S18>/Unary_Minus' : Unused code path elimination\r\n//  Block '<S219>/Offset' : Unused code path elimination\r\n//  Block '<S219>/Unary_Minus' : Unused code path elimination\r\n\r\n\r\n//-\r\n//  The generated code includes comments that allow you to trace directly\r\n//  back to the appropriate location in the model.  The basic format\r\n//  is <system>/block_name, where system is the system number (uniquely\r\n//  assigned by Simulink) and block_name is the name of the block.\r\n//\r\n//  Use the MATLAB hilite_system command to trace the generated code back\r\n//  to the model.  For example,\r\n//\r\n//  hilite_system('<S3>')    - opens system 3\r\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n//\r\n//  Here is the system hierarchy for this model\r\n//\r\n//  '<Root>' : 'inv_mot_controller_v2'\r\n//  '<S1>'   : 'inv_mot_controller_v2/Cartesian to Polar'\r\n//  '<S2>'   : 'inv_mot_controller_v2/Clarke Transform'\r\n//  '<S3>'   : 'inv_mot_controller_v2/Compare To Constant'\r\n//  '<S4>'   : 'inv_mot_controller_v2/Compare To Constant1'\r\n//  '<S5>'   : 'inv_mot_controller_v2/Compare To Constant2'\r\n//  '<S6>'   : 'inv_mot_controller_v2/Compare To Zero'\r\n//  '<S7>'   : 'inv_mot_controller_v2/IIR Filter'\r\n//  '<S8>'   : 'inv_mot_controller_v2/Inverse Park Transform'\r\n//  '<S9>'   : 'inv_mot_controller_v2/PID Controller1'\r\n//  '<S10>'  : 'inv_mot_controller_v2/PID Controller2'\r\n//  '<S11>'  : 'inv_mot_controller_v2/PID Controller3'\r\n//  '<S12>'  : 'inv_mot_controller_v2/PID Controller4'\r\n//  '<S13>'  : 'inv_mot_controller_v2/Park Transform'\r\n//  '<S14>'  : 'inv_mot_controller_v2/SVPWM'\r\n//  '<S15>'  : 'inv_mot_controller_v2/IIR Filter/IIR Filter'\r\n//  '<S16>'  : 'inv_mot_controller_v2/IIR Filter/IIR Filter/Low-pass'\r\n//  '<S17>'  : 'inv_mot_controller_v2/IIR Filter/IIR Filter/Low-pass/IIR Low Pass Filter'\r\n//  '<S18>'  : 'inv_mot_controller_v2/Inverse Park Transform/Switch_Axis'\r\n//  '<S19>'  : 'inv_mot_controller_v2/PID Controller1/Anti-windup'\r\n//  '<S20>'  : 'inv_mot_controller_v2/PID Controller1/D Gain'\r\n//  '<S21>'  : 'inv_mot_controller_v2/PID Controller1/Filter'\r\n//  '<S22>'  : 'inv_mot_controller_v2/PID Controller1/Filter ICs'\r\n//  '<S23>'  : 'inv_mot_controller_v2/PID Controller1/I Gain'\r\n//  '<S24>'  : 'inv_mot_controller_v2/PID Controller1/Ideal P Gain'\r\n//  '<S25>'  : 'inv_mot_controller_v2/PID Controller1/Ideal P Gain Fdbk'\r\n//  '<S26>'  : 'inv_mot_controller_v2/PID Controller1/Integrator'\r\n//  '<S27>'  : 'inv_mot_controller_v2/PID Controller1/Integrator ICs'\r\n//  '<S28>'  : 'inv_mot_controller_v2/PID Controller1/N Copy'\r\n//  '<S29>'  : 'inv_mot_controller_v2/PID Controller1/N Gain'\r\n//  '<S30>'  : 'inv_mot_controller_v2/PID Controller1/P Copy'\r\n//  '<S31>'  : 'inv_mot_controller_v2/PID Controller1/Parallel P Gain'\r\n//  '<S32>'  : 'inv_mot_controller_v2/PID Controller1/Reset Signal'\r\n//  '<S33>'  : 'inv_mot_controller_v2/PID Controller1/Saturation'\r\n//  '<S34>'  : 'inv_mot_controller_v2/PID Controller1/Saturation Fdbk'\r\n//  '<S35>'  : 'inv_mot_controller_v2/PID Controller1/Sum'\r\n//  '<S36>'  : 'inv_mot_controller_v2/PID Controller1/Sum Fdbk'\r\n//  '<S37>'  : 'inv_mot_controller_v2/PID Controller1/Tracking Mode'\r\n//  '<S38>'  : 'inv_mot_controller_v2/PID Controller1/Tracking Mode Sum'\r\n//  '<S39>'  : 'inv_mot_controller_v2/PID Controller1/Tsamp - Integral'\r\n//  '<S40>'  : 'inv_mot_controller_v2/PID Controller1/Tsamp - Ngain'\r\n//  '<S41>'  : 'inv_mot_controller_v2/PID Controller1/postSat Signal'\r\n//  '<S42>'  : 'inv_mot_controller_v2/PID Controller1/preSat Signal'\r\n//  '<S43>'  : 'inv_mot_controller_v2/PID Controller1/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S44>'  : 'inv_mot_controller_v2/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S45>'  : 'inv_mot_controller_v2/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n//  '<S46>'  : 'inv_mot_controller_v2/PID Controller1/D Gain/Disabled'\r\n//  '<S47>'  : 'inv_mot_controller_v2/PID Controller1/Filter/Disabled'\r\n//  '<S48>'  : 'inv_mot_controller_v2/PID Controller1/Filter ICs/Disabled'\r\n//  '<S49>'  : 'inv_mot_controller_v2/PID Controller1/I Gain/Internal Parameters'\r\n//  '<S50>'  : 'inv_mot_controller_v2/PID Controller1/Ideal P Gain/Passthrough'\r\n//  '<S51>'  : 'inv_mot_controller_v2/PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n//  '<S52>'  : 'inv_mot_controller_v2/PID Controller1/Integrator/Discrete'\r\n//  '<S53>'  : 'inv_mot_controller_v2/PID Controller1/Integrator ICs/Internal IC'\r\n//  '<S54>'  : 'inv_mot_controller_v2/PID Controller1/N Copy/Disabled wSignal Specification'\r\n//  '<S55>'  : 'inv_mot_controller_v2/PID Controller1/N Gain/Disabled'\r\n//  '<S56>'  : 'inv_mot_controller_v2/PID Controller1/P Copy/Disabled'\r\n//  '<S57>'  : 'inv_mot_controller_v2/PID Controller1/Parallel P Gain/Internal Parameters'\r\n//  '<S58>'  : 'inv_mot_controller_v2/PID Controller1/Reset Signal/Disabled'\r\n//  '<S59>'  : 'inv_mot_controller_v2/PID Controller1/Saturation/Enabled'\r\n//  '<S60>'  : 'inv_mot_controller_v2/PID Controller1/Saturation Fdbk/Disabled'\r\n//  '<S61>'  : 'inv_mot_controller_v2/PID Controller1/Sum/Sum_PI'\r\n//  '<S62>'  : 'inv_mot_controller_v2/PID Controller1/Sum Fdbk/Disabled'\r\n//  '<S63>'  : 'inv_mot_controller_v2/PID Controller1/Tracking Mode/Disabled'\r\n//  '<S64>'  : 'inv_mot_controller_v2/PID Controller1/Tracking Mode Sum/Passthrough'\r\n//  '<S65>'  : 'inv_mot_controller_v2/PID Controller1/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S66>'  : 'inv_mot_controller_v2/PID Controller1/Tsamp - Ngain/Passthrough'\r\n//  '<S67>'  : 'inv_mot_controller_v2/PID Controller1/postSat Signal/Forward_Path'\r\n//  '<S68>'  : 'inv_mot_controller_v2/PID Controller1/preSat Signal/Forward_Path'\r\n//  '<S69>'  : 'inv_mot_controller_v2/PID Controller2/Anti-windup'\r\n//  '<S70>'  : 'inv_mot_controller_v2/PID Controller2/D Gain'\r\n//  '<S71>'  : 'inv_mot_controller_v2/PID Controller2/Filter'\r\n//  '<S72>'  : 'inv_mot_controller_v2/PID Controller2/Filter ICs'\r\n//  '<S73>'  : 'inv_mot_controller_v2/PID Controller2/I Gain'\r\n//  '<S74>'  : 'inv_mot_controller_v2/PID Controller2/Ideal P Gain'\r\n//  '<S75>'  : 'inv_mot_controller_v2/PID Controller2/Ideal P Gain Fdbk'\r\n//  '<S76>'  : 'inv_mot_controller_v2/PID Controller2/Integrator'\r\n//  '<S77>'  : 'inv_mot_controller_v2/PID Controller2/Integrator ICs'\r\n//  '<S78>'  : 'inv_mot_controller_v2/PID Controller2/N Copy'\r\n//  '<S79>'  : 'inv_mot_controller_v2/PID Controller2/N Gain'\r\n//  '<S80>'  : 'inv_mot_controller_v2/PID Controller2/P Copy'\r\n//  '<S81>'  : 'inv_mot_controller_v2/PID Controller2/Parallel P Gain'\r\n//  '<S82>'  : 'inv_mot_controller_v2/PID Controller2/Reset Signal'\r\n//  '<S83>'  : 'inv_mot_controller_v2/PID Controller2/Saturation'\r\n//  '<S84>'  : 'inv_mot_controller_v2/PID Controller2/Saturation Fdbk'\r\n//  '<S85>'  : 'inv_mot_controller_v2/PID Controller2/Sum'\r\n//  '<S86>'  : 'inv_mot_controller_v2/PID Controller2/Sum Fdbk'\r\n//  '<S87>'  : 'inv_mot_controller_v2/PID Controller2/Tracking Mode'\r\n//  '<S88>'  : 'inv_mot_controller_v2/PID Controller2/Tracking Mode Sum'\r\n//  '<S89>'  : 'inv_mot_controller_v2/PID Controller2/Tsamp - Integral'\r\n//  '<S90>'  : 'inv_mot_controller_v2/PID Controller2/Tsamp - Ngain'\r\n//  '<S91>'  : 'inv_mot_controller_v2/PID Controller2/postSat Signal'\r\n//  '<S92>'  : 'inv_mot_controller_v2/PID Controller2/preSat Signal'\r\n//  '<S93>'  : 'inv_mot_controller_v2/PID Controller2/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S94>'  : 'inv_mot_controller_v2/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S95>'  : 'inv_mot_controller_v2/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone/External'\r\n//  '<S96>'  : 'inv_mot_controller_v2/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone/External/Dead Zone Dynamic'\r\n//  '<S97>'  : 'inv_mot_controller_v2/PID Controller2/D Gain/Disabled'\r\n//  '<S98>'  : 'inv_mot_controller_v2/PID Controller2/Filter/Disabled'\r\n//  '<S99>'  : 'inv_mot_controller_v2/PID Controller2/Filter ICs/Disabled'\r\n//  '<S100>' : 'inv_mot_controller_v2/PID Controller2/I Gain/Internal Parameters'\r\n//  '<S101>' : 'inv_mot_controller_v2/PID Controller2/Ideal P Gain/Passthrough'\r\n//  '<S102>' : 'inv_mot_controller_v2/PID Controller2/Ideal P Gain Fdbk/Disabled'\r\n//  '<S103>' : 'inv_mot_controller_v2/PID Controller2/Integrator/Discrete'\r\n//  '<S104>' : 'inv_mot_controller_v2/PID Controller2/Integrator ICs/Internal IC'\r\n//  '<S105>' : 'inv_mot_controller_v2/PID Controller2/N Copy/Disabled wSignal Specification'\r\n//  '<S106>' : 'inv_mot_controller_v2/PID Controller2/N Gain/Disabled'\r\n//  '<S107>' : 'inv_mot_controller_v2/PID Controller2/P Copy/Disabled'\r\n//  '<S108>' : 'inv_mot_controller_v2/PID Controller2/Parallel P Gain/Internal Parameters'\r\n//  '<S109>' : 'inv_mot_controller_v2/PID Controller2/Reset Signal/External Reset'\r\n//  '<S110>' : 'inv_mot_controller_v2/PID Controller2/Saturation/External'\r\n//  '<S111>' : 'inv_mot_controller_v2/PID Controller2/Saturation/External/Saturation Dynamic'\r\n//  '<S112>' : 'inv_mot_controller_v2/PID Controller2/Saturation Fdbk/Disabled'\r\n//  '<S113>' : 'inv_mot_controller_v2/PID Controller2/Sum/Sum_PI'\r\n//  '<S114>' : 'inv_mot_controller_v2/PID Controller2/Sum Fdbk/Disabled'\r\n//  '<S115>' : 'inv_mot_controller_v2/PID Controller2/Tracking Mode/Disabled'\r\n//  '<S116>' : 'inv_mot_controller_v2/PID Controller2/Tracking Mode Sum/Passthrough'\r\n//  '<S117>' : 'inv_mot_controller_v2/PID Controller2/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S118>' : 'inv_mot_controller_v2/PID Controller2/Tsamp - Ngain/Passthrough'\r\n//  '<S119>' : 'inv_mot_controller_v2/PID Controller2/postSat Signal/Forward_Path'\r\n//  '<S120>' : 'inv_mot_controller_v2/PID Controller2/preSat Signal/Forward_Path'\r\n//  '<S121>' : 'inv_mot_controller_v2/PID Controller3/Anti-windup'\r\n//  '<S122>' : 'inv_mot_controller_v2/PID Controller3/D Gain'\r\n//  '<S123>' : 'inv_mot_controller_v2/PID Controller3/Filter'\r\n//  '<S124>' : 'inv_mot_controller_v2/PID Controller3/Filter ICs'\r\n//  '<S125>' : 'inv_mot_controller_v2/PID Controller3/I Gain'\r\n//  '<S126>' : 'inv_mot_controller_v2/PID Controller3/Ideal P Gain'\r\n//  '<S127>' : 'inv_mot_controller_v2/PID Controller3/Ideal P Gain Fdbk'\r\n//  '<S128>' : 'inv_mot_controller_v2/PID Controller3/Integrator'\r\n//  '<S129>' : 'inv_mot_controller_v2/PID Controller3/Integrator ICs'\r\n//  '<S130>' : 'inv_mot_controller_v2/PID Controller3/N Copy'\r\n//  '<S131>' : 'inv_mot_controller_v2/PID Controller3/N Gain'\r\n//  '<S132>' : 'inv_mot_controller_v2/PID Controller3/P Copy'\r\n//  '<S133>' : 'inv_mot_controller_v2/PID Controller3/Parallel P Gain'\r\n//  '<S134>' : 'inv_mot_controller_v2/PID Controller3/Reset Signal'\r\n//  '<S135>' : 'inv_mot_controller_v2/PID Controller3/Saturation'\r\n//  '<S136>' : 'inv_mot_controller_v2/PID Controller3/Saturation Fdbk'\r\n//  '<S137>' : 'inv_mot_controller_v2/PID Controller3/Sum'\r\n//  '<S138>' : 'inv_mot_controller_v2/PID Controller3/Sum Fdbk'\r\n//  '<S139>' : 'inv_mot_controller_v2/PID Controller3/Tracking Mode'\r\n//  '<S140>' : 'inv_mot_controller_v2/PID Controller3/Tracking Mode Sum'\r\n//  '<S141>' : 'inv_mot_controller_v2/PID Controller3/Tsamp - Integral'\r\n//  '<S142>' : 'inv_mot_controller_v2/PID Controller3/Tsamp - Ngain'\r\n//  '<S143>' : 'inv_mot_controller_v2/PID Controller3/postSat Signal'\r\n//  '<S144>' : 'inv_mot_controller_v2/PID Controller3/preSat Signal'\r\n//  '<S145>' : 'inv_mot_controller_v2/PID Controller3/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S146>' : 'inv_mot_controller_v2/PID Controller3/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S147>' : 'inv_mot_controller_v2/PID Controller3/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n//  '<S148>' : 'inv_mot_controller_v2/PID Controller3/D Gain/Disabled'\r\n//  '<S149>' : 'inv_mot_controller_v2/PID Controller3/Filter/Disabled'\r\n//  '<S150>' : 'inv_mot_controller_v2/PID Controller3/Filter ICs/Disabled'\r\n//  '<S151>' : 'inv_mot_controller_v2/PID Controller3/I Gain/Internal Parameters'\r\n//  '<S152>' : 'inv_mot_controller_v2/PID Controller3/Ideal P Gain/Passthrough'\r\n//  '<S153>' : 'inv_mot_controller_v2/PID Controller3/Ideal P Gain Fdbk/Disabled'\r\n//  '<S154>' : 'inv_mot_controller_v2/PID Controller3/Integrator/Discrete'\r\n//  '<S155>' : 'inv_mot_controller_v2/PID Controller3/Integrator ICs/Internal IC'\r\n//  '<S156>' : 'inv_mot_controller_v2/PID Controller3/N Copy/Disabled wSignal Specification'\r\n//  '<S157>' : 'inv_mot_controller_v2/PID Controller3/N Gain/Disabled'\r\n//  '<S158>' : 'inv_mot_controller_v2/PID Controller3/P Copy/Disabled'\r\n//  '<S159>' : 'inv_mot_controller_v2/PID Controller3/Parallel P Gain/Internal Parameters'\r\n//  '<S160>' : 'inv_mot_controller_v2/PID Controller3/Reset Signal/Disabled'\r\n//  '<S161>' : 'inv_mot_controller_v2/PID Controller3/Saturation/Enabled'\r\n//  '<S162>' : 'inv_mot_controller_v2/PID Controller3/Saturation Fdbk/Disabled'\r\n//  '<S163>' : 'inv_mot_controller_v2/PID Controller3/Sum/Sum_PI'\r\n//  '<S164>' : 'inv_mot_controller_v2/PID Controller3/Sum Fdbk/Disabled'\r\n//  '<S165>' : 'inv_mot_controller_v2/PID Controller3/Tracking Mode/Disabled'\r\n//  '<S166>' : 'inv_mot_controller_v2/PID Controller3/Tracking Mode Sum/Passthrough'\r\n//  '<S167>' : 'inv_mot_controller_v2/PID Controller3/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S168>' : 'inv_mot_controller_v2/PID Controller3/Tsamp - Ngain/Passthrough'\r\n//  '<S169>' : 'inv_mot_controller_v2/PID Controller3/postSat Signal/Forward_Path'\r\n//  '<S170>' : 'inv_mot_controller_v2/PID Controller3/preSat Signal/Forward_Path'\r\n//  '<S171>' : 'inv_mot_controller_v2/PID Controller4/Anti-windup'\r\n//  '<S172>' : 'inv_mot_controller_v2/PID Controller4/D Gain'\r\n//  '<S173>' : 'inv_mot_controller_v2/PID Controller4/Filter'\r\n//  '<S174>' : 'inv_mot_controller_v2/PID Controller4/Filter ICs'\r\n//  '<S175>' : 'inv_mot_controller_v2/PID Controller4/I Gain'\r\n//  '<S176>' : 'inv_mot_controller_v2/PID Controller4/Ideal P Gain'\r\n//  '<S177>' : 'inv_mot_controller_v2/PID Controller4/Ideal P Gain Fdbk'\r\n//  '<S178>' : 'inv_mot_controller_v2/PID Controller4/Integrator'\r\n//  '<S179>' : 'inv_mot_controller_v2/PID Controller4/Integrator ICs'\r\n//  '<S180>' : 'inv_mot_controller_v2/PID Controller4/N Copy'\r\n//  '<S181>' : 'inv_mot_controller_v2/PID Controller4/N Gain'\r\n//  '<S182>' : 'inv_mot_controller_v2/PID Controller4/P Copy'\r\n//  '<S183>' : 'inv_mot_controller_v2/PID Controller4/Parallel P Gain'\r\n//  '<S184>' : 'inv_mot_controller_v2/PID Controller4/Reset Signal'\r\n//  '<S185>' : 'inv_mot_controller_v2/PID Controller4/Saturation'\r\n//  '<S186>' : 'inv_mot_controller_v2/PID Controller4/Saturation Fdbk'\r\n//  '<S187>' : 'inv_mot_controller_v2/PID Controller4/Sum'\r\n//  '<S188>' : 'inv_mot_controller_v2/PID Controller4/Sum Fdbk'\r\n//  '<S189>' : 'inv_mot_controller_v2/PID Controller4/Tracking Mode'\r\n//  '<S190>' : 'inv_mot_controller_v2/PID Controller4/Tracking Mode Sum'\r\n//  '<S191>' : 'inv_mot_controller_v2/PID Controller4/Tsamp - Integral'\r\n//  '<S192>' : 'inv_mot_controller_v2/PID Controller4/Tsamp - Ngain'\r\n//  '<S193>' : 'inv_mot_controller_v2/PID Controller4/postSat Signal'\r\n//  '<S194>' : 'inv_mot_controller_v2/PID Controller4/preSat Signal'\r\n//  '<S195>' : 'inv_mot_controller_v2/PID Controller4/Anti-windup/Disabled'\r\n//  '<S196>' : 'inv_mot_controller_v2/PID Controller4/D Gain/Disabled'\r\n//  '<S197>' : 'inv_mot_controller_v2/PID Controller4/Filter/Disabled'\r\n//  '<S198>' : 'inv_mot_controller_v2/PID Controller4/Filter ICs/Disabled'\r\n//  '<S199>' : 'inv_mot_controller_v2/PID Controller4/I Gain/Disabled'\r\n//  '<S200>' : 'inv_mot_controller_v2/PID Controller4/Ideal P Gain/Passthrough'\r\n//  '<S201>' : 'inv_mot_controller_v2/PID Controller4/Ideal P Gain Fdbk/Disabled'\r\n//  '<S202>' : 'inv_mot_controller_v2/PID Controller4/Integrator/Disabled'\r\n//  '<S203>' : 'inv_mot_controller_v2/PID Controller4/Integrator ICs/Disabled'\r\n//  '<S204>' : 'inv_mot_controller_v2/PID Controller4/N Copy/Disabled wSignal Specification'\r\n//  '<S205>' : 'inv_mot_controller_v2/PID Controller4/N Gain/Disabled'\r\n//  '<S206>' : 'inv_mot_controller_v2/PID Controller4/P Copy/Disabled'\r\n//  '<S207>' : 'inv_mot_controller_v2/PID Controller4/Parallel P Gain/Internal Parameters'\r\n//  '<S208>' : 'inv_mot_controller_v2/PID Controller4/Reset Signal/Disabled'\r\n//  '<S209>' : 'inv_mot_controller_v2/PID Controller4/Saturation/Enabled'\r\n//  '<S210>' : 'inv_mot_controller_v2/PID Controller4/Saturation Fdbk/Disabled'\r\n//  '<S211>' : 'inv_mot_controller_v2/PID Controller4/Sum/Passthrough_P'\r\n//  '<S212>' : 'inv_mot_controller_v2/PID Controller4/Sum Fdbk/Disabled'\r\n//  '<S213>' : 'inv_mot_controller_v2/PID Controller4/Tracking Mode/Disabled'\r\n//  '<S214>' : 'inv_mot_controller_v2/PID Controller4/Tracking Mode Sum/Passthrough'\r\n//  '<S215>' : 'inv_mot_controller_v2/PID Controller4/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S216>' : 'inv_mot_controller_v2/PID Controller4/Tsamp - Ngain/Passthrough'\r\n//  '<S217>' : 'inv_mot_controller_v2/PID Controller4/postSat Signal/Forward_Path'\r\n//  '<S218>' : 'inv_mot_controller_v2/PID Controller4/preSat Signal/Forward_Path'\r\n//  '<S219>' : 'inv_mot_controller_v2/Park Transform/Switch_Axis'\r\n\r\n#endif                                 // RTW_HEADER_inv_mot_controller_v2_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\WORK\\MATLAB_models\\Mospoly\\Kamaz_electric_brakes_v2\\controller_r2023a\\inv_mot_controller_v2_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// File: rtwtypes.h\r\n//\r\n// Code generated for Simulink model 'inv_mot_controller_v2'.\r\n//\r\n// Model version                  : 1.4\r\n// Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n// C/C++ source code generated on : Thu May 23 22:34:38 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n// Logical type definitions\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n//=======================================================================*\r\n//  Target hardware information\r\n//    Device type: ARM Compatible->ARM Cortex-M\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32    long long:  64\r\n//                        native word size:  32\r\n//    Byte ordering: LittleEndian\r\n//    Signed integer division rounds to: Zero\r\n//    Shift right on a signed integer as arithmetic shift: on\r\n// =======================================================================\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n//=======================================================================*\r\n//  Min and Max:                                                          *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n// =======================================================================\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n// Block D-Work pointer type\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 // RTWTYPES_H\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};